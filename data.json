{
    "Programming": [
      {
        "id": "Insert int.",
        "category": "Intervals",
        "placeHolderCpp": "vector<Interval> insertInterval(vector<Interval>& intervals, Interval newInterval) { ... }",
        "placeHolderGo": "func insertInterval(intervals []Interval, newInterval Interval) []Interval { ... }",
        "spaceComplexity": "O(N)",
        "timeComplexity": "O(N)",
        "difficulty": "Medium",
        "question": "Insert interval",
        "answerImage": "",
        "answerCpp": "vector<Interval> insertInterval(vector<Interval>& intervals, Interval newInterval) {\n    vector<Interval> result;\n    int i = 0;\n    int n = intervals.size();\n\n    while (i < n && intervals[i].end < newInterval.start) {\n        result.push_back(intervals[i++]);\n    }\n\n    while (i < n && intervals[i].start <= newInterval.end) {\n        newInterval.start = min(newInterval.start, intervals[i].start);\n        newInterval.end = max(newInterval.end, intervals[i].end);\n        i++;\n    }\n\n    result.push_back(newInterval);\n\n    while (i < n) {\n        result.push_back(intervals[i++]);\n    }\n\n    return result;\n}",
        "answerGo": "func insertInterval(intervals []Interval, newInterval Interval) []Interval {\n    result := []Interval{}\n    i := 0\n    n := len(intervals)\n\n    for i < n && intervals[i].End < newInterval.Start {\n        result = append(result, intervals[i])\n        i++\n    }\n\n    for i < n && intervals[i].Start <= newInterval.End {\n        newInterval.Start = min(newInterval.Start, intervals[i].Start)\n        newInterval.End = max(newInterval.End, intervals[i].End)\n        i++\n    }\n\n    result = append(result, newInterval)\n\n    for i < n {\n        result = append(result, intervals[i])\n        i++\n    }\n\n    return result\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}"
      },
      {
        "id": "Merge int.",
        "category": "Intervals",
        "placeHolderCpp": "vector<Interval> mergeIntervals(vector<Interval>& intervals) { ...}",
        "placeHolderGo": "func mergeIntervals(intervals []Interval) []Interval { ...}",
        "spaceComplexity": "O(N)",
        "timeComplexity": "O(NlogN)",
        "difficulty": "Medium",
        "question": "Merge intervals",
        "answerImage": "",
        "answerCpp": "vector<Interval> mergeIntervals(vector<Interval>& intervals) { if (intervals.empty()) return {}; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b) { return a.start < b.start; }); vector<Interval> merged; merged.push_back(intervals[0]); for (int i = 1; i < intervals.size(); ++i) { if (merged.back().end >= intervals[i].start) { merged.back().end = max(merged.back().end, intervals[i].end); } else { merged.push_back(intervals[i]); } } return merged;}",
        "answerGo": "func mergeIntervals(intervals[]Interval)[]Interval { if len(intervals) == 0 { return nil } sort.Slice(intervals, func(i, j int) bool { return intervals[i].Start < intervals[j].Start }) merged:= []Interval{ intervals[0] } for i := 1; i < len(intervals); i++ { lastMerged:= & merged[len(merged) - 1 if lastMerged.End >= intervals[i].Start { lastMerged.End = max(lastMerged.End, intervals[i].End) } else { merged = append(merged, intervals[i]) } } return merged}func max(a, b int) int { if a > b { return a } return b} "
      },
      {
        "id": "Meeting rooms",
        "category": "Intervals",
        "placeHolderCpp": "int minMeetingRooms(vector<Interval>& intervals) { ...}",
        "placeHolderGo": "func minMeetingRooms(intervals [][]int) int { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Medium",
        "question": "Min meeting room",
        "answerImage": "",
        "answerCpp": "int minMeetingRooms(vector<Interval>& intervals) { vector<int> startTimes, endTimes; for (const auto& interval : intervals) { startTimes.push_back(interval.start); endTimes.push_back(interval.end); } sort(startTimes.begin(), startTimes.end()); sort(endTimes.begin(), endTimes.end()); int rooms = 0, j = 0; for (int i = 0; i < startTimes.size(); ++i) { if (startTimes[i] < endTimes[j]) { rooms++; } else { j++; } } return rooms;}",
        "answerGo": "type Interval struct { start int end int}func minMeetingRooms(intervals []Interval) int { startTimes := make([]int, 0) endTimes := make([]int, 0) for _, v := range intervals { startTimes = append(startTimes, v.start) endTimes = append(endTimes, v.end) } sort.Slice(startTimes, func(i, j int) bool { return startTimes[i] > startTimes[j }) sort.Slice(endTimes, func(i, j int) bool { return endTimes[i] > endTimes[j }) rooms := 0 j := 0 for i := 0; i < len(startTimes); i++ { if startTimes[i] < endTimes[j] { rooms++ } else { j++ } } return rooms}"
      },
      {
        "id": "N queens",
        "category": "Backtracking",
        "placeHolderCpp": "void solveNQueens(int row, vector<string> &board, vector<vector<string>> &solutions, int n) { ...};",
        "placeHolderGo": "func solveNQueens(n int)[][]string {  ... }; ",
        "difficulty": "Hard",
        "question": "Solve the N-Queens Problem",
        "answerImage": "",
        "answerCpp": "void solveNQueens(int row, vector<string> &board, vector<vector<string>> &solutions, int n) { if (row == n) { solutions.push_back(board); return; } for (int col = 0; col < n; ++col) { if (isSafe(row, col, board, n)) { board[row][col] = 'Q'; solveNQueens(row + 1, board, solutions, n); board[row][col] = '.'; } }}bool isSafe(int row, int col, vector<string> &board, int n) { for (int i = 0; i < row; ++i) { if (board[i][col] == 'Q') return false; } for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) { if (board[i][j] == 'Q') return false; } for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j) { if (board[i][j] == 'Q') return false; } return true;}",
        "answerGo": "func solveNQueens(n int) [][]string { board := make([][]string, n) for i := range board { board[i] = make([]string, n) for j := range board[i] { board[i][j] = '.' } } solutions := [][]string{} solve(0, n, &board, &solutions) return solutions}func solve(row, n int, board *[][]string, solutions *[][]string) { if row == n { solution := make([]string, n) for i := 0; i < n; i++ { solution[i] = strings.Join((*board)[i], '') } *solutions = append(*solutions, solution) return } for col := 0; col < n; col++ { if isSafe(row, col, *board, n) { (*board)[row][col] = 'Q' solve(row+1, n, board, solutions) (*board)[row][col] = '.' } }}func isSafe(row, col int, board [][]string, n int) bool { for i := 0; i < row; i++ { if board[i][col] == 'Q' { return false } } for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 { if board[i][j] == 'Q' { return false } } for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 { if board[i][j] == 'Q' { return false } } return true}"
      },
      {
        "id": "dsu",
        "category": "Disjoint Set",
        "placeHolderCpp": "class DSU { ...};",
        "placeHolderGo": "type DSU struct { ...};",
        "spaceComplexity": "O(N)",
        "timeComplexity": "O(M x Î±(N))",
        "difficulty": "Medium",
        "question": "Disjoint Set Union",
        "answerImage": "../code-snipets/dsu.png",
        "answerCpp": "class DSU {public: DSU(int n) : _p(n), _r(n, 0) { for (int i = 0; i < n; ++i) _p[i] = i; } int find(int v) { return v == _p[v] ? v : _p[v] = find(_p[v]); } void merge(int a, int b) { a = find(a); b = find(b); if (a != b) { if (_r[a] < _r[b]) swap(a, b); _p[b] = a; if (_r[a] == _r[b]) _r[a]++; } } private: vector<int> _p, _r;};",
        "answerGo": "type DSU struct { parent []int rank []int}func NewDSU(n int) *DSU { dsu := &DSU{ parent: make([]int, n), rank: make([]int, n), } for i := 0; i < n; i++ { dsu.parent[i] = i } return dsu}func (dsu *DSU) Find(v int) int { if dsu.parent[v] != v { dsu.parent[v] = dsu.Find(dsu.parent[v]) } return dsu.parent[v}func (dsu *DSU) Merge(a, b int) { rootA := dsu.Find(a) rootB := dsu.Find(b) if rootA != rootB { if dsu.rank[rootA] < dsu.rank[rootB] { dsu.parent[rootA] = rootB } else if dsu.rank[rootA] > dsu.rank[rootB] { dsu.parent[rootB] = rootA } else { dsu.parent[rootB] = rootA dsu.rank[rootA]++ } }}"
      },
      {
        "id": "dfs rec.",
        "category": "Graph",
        "placeHolderCpp": "void dfs(int node) { ...}",
        "placeHolderGo": "func dfs(node int) { ...}",
        "spaceComplexity": "O(E + V)",
        "timeComplexity": "O(E + V)",
        "difficulty": "Easy",
        "question": "DFS (Depth first search) recursive",
        "answerImage": "../code-snipe ts/dfs_recursive.png",
        "answerCpp": "void dfs(int node) { visited[node] = true; cout << node; for (int nei : graph[node]) { if (visited[nei]) continue; dfs(nei); }}",
        "answerGo": "func dfs(node int) { visited[node] = true fmt.Println(node) for _, nei := range graph[node] { if visited[nei] { continue } dfs(nei) }}"
      },
      {
        "id": "bfs it.",
        "category": "Graph",
        "placeHolderCpp": "void bfs(int start) { ...}",
        "placeHolderGo": "func bfs(start int) {{ ...}",
        "spaceComplexity": "O(E + V)",
        "timeComplexity": "O(E + V)",
        "difficulty": "Medium",
        "question": "BFS (Bread first search) iterative",
        "answerImage": "../code-snipets/bfs_iterative.png",
        "answerCpp": "void bfs(int start) { map<int, bool> visited; queue<int> q; q.push(start); visited[start] = true; while (!q.empty()) { int node = q.front(); q.pop(); cout << node; for (int nei : graph[node]) { if (visited[nei]) continue; visited[nei] = true; q.push(nei); } }}",
        "answerGo": "func bfs(start int) { visited := make(map[int]bool) q := []int{start} visited[start] = true for len(q) > 0 { node := q[0 q = q[1: fmt.Println(node) for _, nei := range graph[node] { if visited[nei] { continue } visited[nei] = true q = append(q, nei) } }}"
      },
      {
        "id": "bfs rec.",
        "category": "Graph",
        "placeHolderCpp": "void bfs(vector<int>& level, map<int, bool>& visited) { ...}",
        "placeHolderGo": "func bfs(level []int, visited map[int]bool) { ...}",
        "spaceComplexity": "O(E + V)",
        "timeComplexity": "O(E + V)",
        "difficulty": "Medium",
        "question": "BFS (Bread first search) recursive",
        "answerImage": "../code-snipets/bfs_recursive.png",
        "answerCpp": "void bfs(vector<int>& level, map<int, bool>& visited) { if (level.empty()) return; vector<int> nlevel; for (int node : level) { cout << node; for (int nei : graph[node]) { if (visited[nei]) continue; visited[nei] = true; nlevel.push_back(nei); } } bfs(nlevel, visited);}",
        "answerGo": "func bfs(level []int, visited map[int]bool) { if len(level) == 0 { return } var nlevel []int for _, node := range level { fmt.Println(node) for _, nei := range graph[node] { if visited[nei] { continue } visited[nei] = true nlevel = append(nlevel, nei) } } bfs(nlevel, visited)}"
      },
      {
        "id": "Dijkstra",
        "category": "Graph",
        "placeHolderCpp": "vector<int> dijkstra(vector<PairType> graph[], int V, int src) { ...}",
        "placeHolderGo": "func dijkstra(graph [][]PairType, V, src int) []int { ...}",
        "spaceComplexity": "O(N)",
        "timeComplexity": "O(E + V)logV",
        "difficulty": "Medium",
        "question": "Dijkstra",
        "answerImage": "",
        "answerCpp": "typedef pair<int, int> PairType;vector<int> dijkstra(vector<PairType>& graph[], int V, int src) { priority_queue<PairType, vector<PairType>, greater<PairType>> pq; vector<int> dist(V, INT_MAX); dist[src] = 0; pq.push({0, src}); while (!pq.empty()) { int node = pq.top().second; pq.pop(); for (auto nei : graph[node]) { int v = nei.first; int w = nei.second; if (dist[v] > dist[node] + w) { dist[v] = dist[node] + w; pq.push({dist[v], v}); } } } return dist;}",
        "answerGo": "func dijkstra(graph [][]PairType, V, src int) []int { dist := make([]int, V) for i := range dist { dist[i] = math.MaxInt } dist[src] = 0 pq := &PriorityQueue{} heap.Push(pq, PairType{0, src}) for pq.Len() > 0 { node := heap.Pop(pq).(PairType).node for _, nei := range graph[node] { v := nei.node w := nei.distance if dist[v] > dist[node] + w { dist[v] = dist[node] + w heap.Push(pq, PairType{dist[v], v}) } } } return dist}"
      },
      {
        "id": "dfs it.",
        "category": "Graph",
        "placeHolderCpp": "void dfs(int start) { ...}",
        "placeHolderGo": "func dfs(start int) { ...}",
        "spaceComplexity": "O(E + V)",
        "timeComplexity": "O(E + V)",
        "difficulty": "Medium",
        "question": "DFS (Depth first search) iterative",
        "answerImage": "../code-snipets/dfs_iterative.png",
        "answerCpp": "void dfs(int start) { map<int, bool> visited; stack<int> stk; stk.push(start); while (!stk.empty()) { int node = stk.top(); stk.pop(); if (visited[node]) continue; cout << node; visited[node] = true; for (int x = graph[node].size() - 1; x >= 0; --x) { int nextNode = graph[node][x]; if (visited[nextNode]) continue; stk.push(nextNode); } }}",
        "answerGo": "func dfs(start int) { visited := make(map[int]bool) stk := []int{ start } for len(stk) > 0 { node := stk[len(stk) - 1 stk = stk[: len(stk)- 1 if visited[node] { continue } fmt.Println(node) visited[node] = true for x := len(graph[node]) - 1; x >= 0; x-- { nextNode := graph[node][x if !visited[nextNode] { stk = append(stk, nextNode) } }}}"
      },
      {
        "id": "Ancestor",
        "category": "Linked List",
        "placeHolderCpp": "ListNode* findAncestor(ListNode* head, int t) { ...}",
        "placeHolderGo": "func findAncestor(head *ListNode, target int) *ListNode { ...}",
        "difficulty": "Medium",
        "question": "Find the Ancestor Element in Linked List",
        "answerImage": "",
        "answerCpp": "ListNode* findAncestor(ListNode* head, int t) { ListNode* prev = nullptr; while (head != nullptr) { if (head->val == t) { return prev; } prev = head; head = head->next; } return nullptr;}",
        "answerGo": "type ListNode struct { Val int Next *ListNode}func findAncestor(head *ListNode, target int) *ListNode { var prev *ListNode for head != nil { if head.Val == target { return prev } prev = head head = head.Next } return nil}"
      },
      {
        "id": "Print list",
        "category": "Linked List",
        "placeHolderCpp": "void printList(ListNode* head) { ...}",
        "placeHolderGo": "{ ...}",
        "difficulty": "Easy",
        "question": "Print linked list",
        "answerImage": "",
        "answerCpp": "void printList(ListNode* head) { while (head != nullptr) { cout << head->val << \" \"; head = head->next; } }",
        "answerGo": ""
      },
      {
        "id": "Insert at end",
        "category": "Linked List",
        "placeHolderCpp": "void insertAtEnd(ListNode** head, int v) { ...}",
        "placeHolderGo": "func insertAtEnd(head **Node, newData int) { ...}func printList(head *Node) { ...}",
        "difficulty": "Medium",
        "question": "Insert at Linked List end",
        "answerImage": "",
        "answerCpp": "void insertAtEnd(ListNode** head, int v) { ListNode* dummy = new ListNode(v); if (*head == nullptr) { *head = dummy; return; } ListNode* temp = *head; while (temp->next != nullptr) { temp = temp->next; } temp->next = dummy;}",
        "answerGo": "type Node struct { data int next *Node}func insertAtEnd(head **Node, newData int) { newNode := &Node{data: newData, next: nil} if *head == nil { *head = newNode return } temp := *head for temp.next != nil { temp = temp.next } temp.next = newNode}func printList(head *Node) { for head != nil { fmt.Printf(\"%d \", head.data) head = head.next }}"
      },
      {
        "id": "List node",
        "category": "Linked List",
        "placeHolderCpp": "struct ListNode { ...}",
        "placeHolderGo": "{ ...}",
        "difficulty": "Easy",
        "question": "ListNode structure",
        "answerImage": "",
        "answerCpp": "struct ListNode { int val; ListNode* next; ListNode(int v) : val(v), next(nullptr) {}}",
        "answerGo": ""
      },
      {
        "id": "Remove element",
        "category": "Linked List",
        "placeHolderCpp": "ListNode* removeElements(ListNode* head, int t) { ...}",
        "placeHolderGo": "func removeElements(head *ListNode, val int) *ListNode { ...}",
        "difficulty": "Medium",
        "question": "Remove all elements from a linked list that have a specific value.",
        "answerImage": "",
        "answerCpp": "ListNode* removeElements(ListNode* head, int t) { ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* prev = dummy; ListNode* curr = head; while (curr != nullptr) { if (curr->val == t) { prev->next = curr->next; } else { prev = curr; } curr = curr->next; } return dummy->next;}",
        "answerGo": "type ListNode struct { Val int Next *ListNode}func removeElements(head *ListNode, val int) *ListNode { dummy := &ListNode{Next: head} prev := dummy curr := head for curr != nil { if curr.Val == val { prev.Next = curr.Next } else { prev = curr } curr = curr.Next } return dummy.Next}func printList(head *ListNode) { for head != nil { fmt.Print(head.Val, \" \") head = head.Next } fmt.Println()}"
      },
      {
        "id": "Reverse list",
        "category": "Linked List",
        "placeHolderCpp": "ListNode* reverseLinkedList(ListNode* head) { ...}",
        "placeHolderGo": "{ ...}",
        "difficulty": "Easy",
        "question": "Reverse linked list",
        "answerImage": "",
        "answerCpp": "ListNode* reverseLinkedList(ListNode* head) { ListNode* prev = nullptr; ListNode* curr = head; ListNode* next = nullptr; while (curr != nullptr) { next = curr->next; curr->next = prev; prev = curr; curr = next; } return prev;}",
        "answerGo": ""
      },
      {
        "id": "Linear search",
        "category": "Searching",
        "placeHolderCpp": "int linearSearch(const vector<int>& nums, int target) { ...}",
        "placeHolderGo": "func linearSearch(nums []int, target int) int {{ ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Easy",
        "question": "Linear search",
        "answerImage": "",
        "answerCpp": "int linearSearch(const vector<int>& nums, int target) { for (int i = 0; i < nums.size(); ++i) { if (nums[i] == target) { return i; } } return -1;}",
        "answerGo": "func linearSearch(nums []int, target int) int { for i := 0; i < len(nums); i++ { if nums[i] == target { return i } } return -1}"
      },
      {
        "id": "Jump search",
        "category": "Searching",
        "placeHolderCpp": "int jumpSearch(const vector<int>& nums, int target) { ...}",
        "placeHolderGo": "func jumpSearch(nums []int, target int) int { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Easy",
        "question": "Jump search",
        "answerImage": "",
        "answerCpp": "int jumpSearch(const vector<int>& arr, int target) { int n = arr.size(); int step = sqrt(n); int prev = 0; while (arr[min(step, n) - 1] < target) { prev = step; step += sqrt(n); if (prev >= n) { return -1; } } for (int i = prev; i < min(step, n); ++i) { if (arr[i] == target) { return i; } } return -1;}",
        "answerGo": "func jumpSearch(nums []int, target int) int { n := len(nums) step := int(math.Sqrt(float64(n))) prev := 0 for nums[min(step, n)-1] < target { prev = step step += int(math.Sqrt(float64(n))) if prev >= n { return -1 } } for i := prev; i < min(step, n); i++ { if nums[i] == target { return i } } return -1}func min(a, b int) int { if a < b { return a } return b}"
      },
      {
        "id": "Interpolation search",
        "category": "Searching",
        "placeHolderCpp": "int interpolationSearch(const vector<int>& arr, int target) { ...}",
        "placeHolderGo": "func interpolationSearch(nums []int, target int) int { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Easy",
        "question": "Interpolation search",
        "answerImage": "",
        "answerCpp": "int interpolationSearch(const vector<int>& arr, int t) { int n = arr.size(); int lo = 0; int hi = n - 1; while (lo <= hi && t >= arr[lo] && t <= arr[hi]) { int pos = lo + ((double)(hi - lo) / (arr[hi] - arr[lo]) (t - arr[lo])); if (arr[pos] == t) { return pos; } if (arr[pos] < t) { lo = pos + 1; } else { hi = pos - 1; } } return -1;}",
        "answerGo": "func interpolationSearch(nums []int, target int) int { n := len(nums) lo, hi := 0, n-1 for lo <= hi && target >= nums[lo] && target <= nums[hi] { if nums[hi] == nums[lo] { if nums[lo] == target { return lo } return -1 } pos := lo + (hi-lo)*(target-nums[lo])/(nums[hi]-nums[lo]) if nums[pos] == target { return pos } if nums[pos] < target { lo = pos + 1 } else { hi = pos - 1 } } return -1}"
      },
      {
        "id": "Topological sort",
        "category": "Topo. Sort",
        "placeHolderCpp": "void dfs(int node, map<int, bool>& visited, stack<int>& stk, vector<int> graph[]) { ...}void topoSortGraph(vector<int> nodes, vector<int> graph[], int V) { ...}",
        "placeHolderGo": "func dfs(node int, visited []bool, stack *[]int, graph [][]int) { ...}void topoSortGraph(vector<int> nodes, vector<int> graph[]) { ...}",
        "difficulty": "Hard",
        "question": "Topological Sort.",
        "answerImage": "",
        "answerCpp": "void dfs(int node, map<int, bool>& visited, stack<int>& stk, vector<int> graph[]) { visited[node] = true; for (int nei : graph[node]) { if (visited[nei]) continue; dfs(nei, visited, stk, graph); } stk.push(node);}void topoSortGraph(vector<int> nodes, vector<int> graph[]) { map<int, bool> visited; stack<int> stk; for (int node : nodes) { if (visited[node]) continue; dfs(node, visited, stk, graph); } while (!stk.empty()) { int node = stk.top(); stk.pop(); cout << node; }}",
        "answerGo": "func dfs(v int, visited []bool, stk *[]int, graph [][]int) { visited[v] = true for _, nei := range graph[v] { if !visited[nei] { dfs(nei, visited, stk, graph) } } *stk = append(*stk, v)}func topoSortGraph(V int, graph [][]int) { visited := make([]bool, V) stk := []int{} for i := 0; i < V; i++ { if !visited[i] { dfs(i, visited, &stk, graph) } } for i := len(stk) - 1; i >= 0; i-- { fmt.Print(stk[i], \" \") }}"
      },
      {
        "id": "binary search",
        "category": "Binary Search",
        "placeHolderCpp": "int binarySearch(vector<int>& nums, int t) { ...}",
        "placeHolderGo": "func binarySearch(nums []int, t int) int { ...}",
        "spaceComplexity": "O(1)",
        "timeComplexity": "O(logN)",
        "difficulty": "Easy",
        "question": "Binary search",
        "answerImage": "../code-snipets/binary_search.png",
        "answerCpp": "int binarySearch(vector<int>& nums, int t) { int n = nums.size(); int lo = 0; int hi = n - 1; while (lo <= hi) { int mi = lo + ((hi - lo) >> 1); if (nums[mi] == t) { return mi; } else if (nums[mi] > t) { hi = mi - 1; } else { lo = mi + 1; } } return -1;}",
        "answerGo": "func binarySearch(nums []int, t int) int { lo := 0 hi := len(nums) - 1 for lo <= hi { mi := lo + (hi-lo)/2 if nums[mi] == t { return mi } else if nums[mi] > t { hi = mi - 1 } else { lo = mi + 1 } } return -1}"
      },
      {
        "id": "merge sort",
        "category": "Div. Conq.",
        "placeHolderCpp": "void mergeSort(vector<int>& arr, int l, int r) { ...}",
        "placeHolderGo": "func mergeSort(arr []int, l, r int) { ...}",
        "difficulty": "Medium",
        "question": "Implement Merge Sort",
        "answerImage": "",
        "answerCpp": "void mergeSort(vector<int>& arr, int l, int r) { if (l >= r) return; int m = l + (r - l) / 2; mergeSort(arr, l, m); mergeSort(arr, m + 1, r); merge(arr, l, m, r);}void merge(vector<int>& arr, int l, int m, int r) { vector<int> left(arr.begin() + l, arr.begin() + m + 1); vector<int> right(arr.begin() + m + 1, arr.begin() + r + 1); int i = 0, j = 0, k = l; while (i < left.size() && j < right.size()) { if (left[i] <= right[j]) arr[k++] = left[i++]; else arr[k++] = right[j++]; } while (i < left.size()) arr[k++] = left[i++]; while (j < right.size()) arr[k++] = right[j++];}",
        "answerGo": "func mergeSort(arr []int, l, r int) { if l >= r { return } m := l + (r - l) / 2 mergeSort(arr, l, m) mergeSort(arr, m + 1, r) merge(arr, l, m, r)}func merge(arr []int, l, m, r int) { left := append([]int{}, arr[l:m+1]...) right := append([]int{}, arr[m+1:r+1]...) i, j, k := 0, 0, l for i < len(left) && j < len(right) { if left[i] <= right[j] { arr[k] = left[i i++ } else { arr[k] = right[j j++ } k++ } for i < len(left) { arr[k] = left[i i++ k++ } for j < len(right) { arr[k] = right[j j++ k++ }}"
      },
      {
        "id": "quick sort",
        "category": "Div. Conq.",
        "placeHolderCpp": "void quickSort(vector<int>& arr, int low, int high) { ...}",
        "placeHolderGo": "func quickSort(arr []int, low, high int)  ...}",
        "difficulty": "Medium",
        "question": "Implement Quick Sort",
        "answerImage": "",
        "answerCpp": "void quickSort(vector<int>& arr, int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); }}int partition(vector<int>& arr, int low, int high) { int pivot = arr[high]; int i = (low - 1); for (int j = low; j < high; j++) { if (arr[j] < pivot) { i++; swap(arr[i], arr[j]); } } swap(arr[i + 1], arr[high]); return (i + 1);} ",
        "answerGo": "func quickSort(arr []int, low, high int) { if low < high { pi := partition(arr, low, high) quickSort(arr, low, pi - 1) quickSort(arr, pi + 1, high) }}func partition(arr []int, low, high int) int { pivot := arr[high i := low - 1 for j := low; j < high; j++ { if arr[j] < pivot { i++ arr[i], arr[j] = arr[j], arr[i } } arr[i + 1], arr[high] = arr[high], arr[i + 1 return i + 1}"
      },
      {
        "id": "Knapsack",
        "category": "Greedy",
        "placeHolderCpp": "double fractionalKnapsack(int W, vector<Item>& items) { ...}",
        "placeHolderGo": "func fractionalKnapsack(W int, items []Item) float64 { ...}",
        "difficulty": "Medium",
        "question": "Fractional Knapsack",
        "answerImage": "",
        "answerCpp": "double fractionalKnapsack(int W, vector<Item>& items) { sort(items.begin(), items.end()); double totalValue = 0.0; for (const auto& item : items) { if (W >= item.weight) { totalValue += item.value; W -= item.weight; } else { totalValue += item.value ((double)W / item.weight); break; } } return totalValue;}",
        "answerGo": "type Item struct { Weight int Value int}func fractionalKnapsack(W int, items []Item) float64 { sort.Slice(items, func(i, j int) bool { return float64(items[i].Value)/float64(items[i].Weight) > float64(items[j].Value)/float64(items[j].Weight) }) totalValue := 0.0 for _, item := range items { if W >= item.Weight { totalValue += float64(item.Value) W -= item.Weight } else { totalValue += float64(item.Value) (float64(W) / float64(item.Weight)) break } } return totalValue}"
      },
      {
        "id": "Fast exp.",
        "category": "Mathematics",
        "placeHolderCpp": "long long power(long long base, long long exp, long long mod) { ...}",
        "placeHolderGo": "func power(base, exp, mod int64) int64 { ...}",
        "difficulty": "Medium",
        "question": "Fast exponentiation",
        "answerImage": "",
        "answerCpp": "long long power(long long base, long long exp, long long mod) { long long result = 1; while (exp > 0) { if (exp % 2 == 1) { result = (result) % mod exp /= 2 } return result}"
      },
      {
        "id": "Sieve",
        "category": "Mathematics",
        "placeHolderCpp": "void sieveOfEratosthenes(int n) { ...}",
        "placeHolderGo": "func sieveOfEratosthenes(n int) { ...}",
        "difficulty": "Medium",
        "question": "Sieve of Eratosthenes",
        "answerImage": "",
        "answerCpp": "void sieveOfEratosthenes(int n) { vector<bool> isPrime(n + 1, true); isPrime[0] = isPrime[1] = false; for (int i = 2; i; j <= n; j += i { isPrime[j] = false } } } for i := 2; i <= n; i++ { if isPrime[i] { fmt.Print(i, \" \") } } fmt.Println()}func main() { sieveOfEratosthenes(30)}"
      },
      {
        "id": "GCD",
        "category": "Mathematics",
        "placeHolderCpp": "int gcd(int a, int b) { ...}",
        "placeHolderGo": "func gcd(a int, b int) int { ...}",
        "difficulty": "Easy",
        "question": "Greatest Common Divisor (GCD)",
        "answerImage": "",
        "answerCpp": "int gcd(int a, int b) { if (b == 0) { return a; } return gcd(b, a % b);}",
        "answerGo": "func gcd(a int, b int) int { if b == 0 { return a } return gcd(b, a % b)}"
      },
      {
        "id": "Lazy propag.",
        "category": "Segment Tree",
        "placeHolderCpp": "vector<int> tree;void build(int node, int start, int end, vector<int>& arr) { ...}int query(int node, int start, int end, int L, int R) { ...}void updateRange(int node, int start, int end, int L, int R, int val) { ...}",
        "placeHolderGo": "type SegmentTree struct { tree []int lazy []int}func (st *SegmentTree) Build(node, start, end int, arr []int) { //...}func (st *SegmentTree) Query(node, start, end, L, R int) int { //...}func (st *SegmentTree) UpdateRange(node, start, end, L, R, val int) { //...}",
        "difficulty": "Hard",
        "question": "Lazy propagation for range updates and range queries.",
        "answerImage": "",
        "answerCpp": "vector<int> tree, lazy;void build(int node, int start, int end, vector<int>& arr) {if (start == end) { tree[node] = arr[start];} else { int mid = (start + end) / 2;",
        "answerGo": ""
      },
      {
        "id": "Trie",
        "category": "Trie",
        "placeHolderCpp": "class Trie { ...};",
        "placeHolderGo": "type TrieNode struct { ...}",
        "difficulty": "Hard",
        "question": "Trie",
        "answerImage": "",
        "answerCpp": "struct TrieNode { bool end; unordered_map<char, shared_ptr<TrieNode>> children;};class Trie {public: Trie() { root = make_unique<TrieNode>(); } void insert(const string& word) { TrieNode* temp = root.get(); for (char c : word) { if (temp->children.find(c) == temp->children.end()) { temp->children[c] = make_unique<TrieNode>(); } temp = temp->children[c].get(); } temp->end = true; } bool search(const string& word) { TrieNode* temp = root.get(); for (char c : word) { if (temp->children.find(c) != temp->children.end()) { temp = temp->children[c].get(); } else { return false; } } return temp->end; } private: unique_ptr<TrieNode> root;};",
        "answerGo": "type TrieNode struct { End bool Children map[rune]*TrieNode}type Trie struct { Root *TrieNode}func NewTrie() *Trie { return &Trie { Root: &TrieNode{ Children: make(map[rune]*TrieNode)}}}func (t *Trie) Insert(word string) { temp := t.Root for _, c := range word { if _, exists := temp.Children[c]; !exists { temp.Children[c] = &TrieNode { Children: make(map[rune]*TrieNode)} } temp = temp.Children[c } temp.End = true}func (t *Trie) Search(word string) bool { temp := t.Root for _, c := range word { if next, exists := temp.Children[c]; exists { temp = next } else { return false } } return temp.End}"
      },
      {
        "id": "power of 2",
        "category": "Bit Manipulation",
        "placeHolderCpp": "bool isPowerOfTwo(int n) { ...};",
        "placeHolderGo": "func isPowerOfTwo(n int) { ...};",
        "difficulty": "Easy",
        "question": "Write a function to check if a given number is a power of two.",
        "answerImage": "",
        "answerCpp": "bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0;}",
        "answerGo": "func isPowerOfTwo(n int) bool { return n > 0 && (n & (n - 1)) == 0}"
      },
      {
        "id": "count set bits",
        "category": "Bit Manipulation",
        "placeHolderCpp": "int countSetBits(int n) { ...};",
        "placeHolderGo": "func countSetBits(n int) int { ...};",
        "difficulty": "Easy",
        "question": "count 1s in the binary representation of an integer.",
        "answerImage": "",
        "answerCpp": "int countSetBits(int n) { int count = 0; while (n) { count += n & 1; n >>= 1; } return count;}",
        "answerGo": "func countSetBits(n int) int { count := 0 for n > 0 { count += n & 1 n >>= 1 } return count}"
      },
      {
        "id": "reverse bits",
        "category": "Bit Manipulation",
        "placeHolderCpp": "uint32_t reverseBits(uint32_t n) { ...};",
        "placeHolderGo": "func reverseBits(n uint32) uint32 { ...};",
        "difficulty": "Medium",
        "question": "Write a function to reverse the bits of a 32-bit unsigned integer.",
        "answerImage": "",
        "answerCpp": "uint32_t reverseBits(uint32_t n) { uint32_t result = 0; for (int i = 0; i < 32; ++i) { result <<= 1; result |= (n & 1); n >>= 1; } return result;}",
        "answerGo": "func reverseBits(n uint32) uint32 { result := uint32(0) for i := 0; i < 32; i++ { result <<= 1 result |= n & 1 n >>= 1 } return result}"
      },
      {
        "id": "kadane",
        "category": "DP",
        "placeHolderCpp": "int kadane(vector<int>& nums) { ...}",
        "placeHolderGo": "func kadane(nums []int) int {{ ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Medium",
        "question": "Maximum subarray sum (Kadane's Algorithm)",
        "answerImage": "../code-snipets/kadane.png",
        "answerCpp": "int kadane(vector<int>& nums) { if (nums.empty()) return 0; int lm = nums[0]; int gm = INT_MIN; for (int i = 0; i < nums.size(); ++i) { lm = max(nums[i], nums[i] + lm); gm = max(gm, lm); } return gm;}",
        "answerGo": "func kadane(nums []int) int { if len(nums) == 0 { return 0 } lm := nums[0 gm := math.MinInt32 for i := 1; i < len(nums); i++ { lm = max(nums[i], nums[i] + lm) gm = max(lm, gm) } return gm}"
      },
      {
        "id": "Insert heap",
        "category": "Heap",
        "placeHolderCpp": "void heapifyUp(vector<int>& heap, int index) { ...}",
        "placeHolderGo": "func heapifyUp(heap []int, index int) { ...}",
        "difficulty": "Easy",
        "question": "Insert an element into a Max Heap.",
        "answerImage": "",
        "answerCpp": "void heapifyUp(vector<int>& heap, int index) { int parent = (index - 1) / 2; if (parent >= 0 && heap[parent] < heap[index]) { swap(heap[parent], heap[index]); heapifyUp(heap, parent); }}void insertMaxHeap(vector<int>& heap, int value) { heap.push_back(value); heapifyUp(heap, heap.size() - 1);}",
        "answerGo": "func heapifyUp(heap []int, index int) { parent := (index - 1) / 2 if parent >= 0 && heap[parent] < heap[index] { heap[parent], heap[index] = heap[index], heap[parent heapifyUp(heap, parent) }}func insertMaxHeap(heap *[]int, value int) { *heap = append(*heap, value) heapifyUp(*heap, len(*heap)-1)}"
      },
      {
        "id": "Heap sort",
        "category": "Heap",
        "placeHolderCpp": "void heapify(vector<int>& arr, int n, int i) { ...}",
        "placeHolderGo": "func heapify(arr []int, n, i int) { ...}",
        "difficulty": "Medium",
        "question": "Heap sort",
        "answerImage": "",
        "answerCpp": "void heapify(vector<int>& arr, int n, int i) { int largest = i; int left = 2i + 2; if (left < n && arr[left] > arr[largest]) { largest = left; } if (right < n && arr[right] > arr[largest]) { largest = right; } if (largest != i) { swap(arr[i], arr[largest]); heapify(arr, n, largest); }}void heapSort(vector<int>& arr, int n) { for (int i = n / 2 - 1; i >= 0; i--) { heapify(arr, n, i); } for (int i = n - 1; i > 0; i--) { swap(arr[0], arr[i]); heapify(arr, i, 0); }}",
        "answerGo": "func heapify(arr []int, n, i int) { largest := i left := 2*i + 1 right := 2*i + 2 if left < n && arr[left] > arr[largest] { largest = left } if right < n && arr[right] > arr[largest] { largest = right } if largest != i { arr[i], arr[largest] = arr[largest], arr[i heapify(arr, n, largest) }}func heapSort(arr []int) { n := len(arr) for i := n/2 - 1; i >= 0; i-- { heapify(arr, n, i) } for i := n - 1; i > 0; i-- { arr[0], arr[i] = arr[i], arr[0 heapify(arr, i, 0) }}"
      },
      {
        "id": "Pigeon hole",
        "category": "Pigeonhole Principle",
        "placeHolderCpp": "int birthdayParadox() { ...}",
        "placeHolderGo": "func birthdayParadox() int { ...}",
        "difficulty": "Easy",
        "question": "Minimum People with 50% chance 2 people have same birthday.",
        "answerImage": "",
        "answerCpp": "int birthdayParadox() { int days = 365; double prob = 1.0; int people = 0; while (prob > 0.5) { people++; prob *= (days - people) / static_cast<double>(days); } return people;}",
        "answerGo": "func birthdayParadox() int { days := 365.0 prob := 1.0 people := 0 for prob > 0.5 { people++ prob *= (days - float64(people)) / days } return people}"
      },
      {
        "id": "Max sub array",
        "category": "Sliding Window",
        "placeHolderCpp": "int maxSumSubArray(vector<int>& nums, int k) { ...}",
        "placeHolderGo": "func maxSumSubArray(arr []int, k int) int { ...}",
        "difficulty": "Medium",
        "question": "find the maximum sum of a subarray of size K.",
        "answerImage": "",
        "answerCpp": "int maxSumSubArray(vector<int>& nums, int k) { int maxSum = 0, windowSum = 0; for (int i = 0; i < k; ++i) { windowSum += nums[i]; } maxSum = windowSum; for (int i = k; i < nums.size(); ++i) { windowSum += nums[i] - nums[i - k]; maxSum = max(maxSum, windowSum); } return maxSum;}",
        "answerGo": "func maxSumSubArray(nums []int, k int) int { windowSum, maxSum := 0, 0 for i := 0; i < k; i++ { windowSum += nums[i } maxSum = windowSum for i := k; i < len(nums); i++ { windowSum += nums[i] - nums[i-k if windowSum > maxSum { maxSum = windowSum } } return maxSum}"
      },
      {
        "id": "Permutations",
        "category": "Combinatorics",
        "placeHolderCpp": "int countPermutations(int n, int k) { int result = 1; for (int i = 0; i < k; ++i) { result *= (n - i); } ...}",
        "placeHolderGo": "func countPermutations(n int, k int) int { result := 1 for i := 0; i < k; i++ { result *= (n - i) } ...}",
        "difficulty": "Medium",
        "question": "Ways to arrange k items from a set of n-length permutations.",
        "answerImage": "",
        "answerCpp": "int countPermutations(int n, int k) { int result = 1; for (int i = 0; i < k; ++i) { result *= (n - i); } return result;}",
        "answerGo": "func countPermutations(n int, k int) int { result := 1 for i := 0; i < k; i++ { result *= (n - i) } return result}"
      },
      {
        "id": "subsets",
        "category": "Combinatorics",
        "placeHolderCpp": "void generateSubsets(const vector<int>& nums, int index, vector<int>& current, vector<vector<int>>& result) { // Recursive function to generate all subsets of a set ...}",
        "placeHolderGo": "func generateSubsets(nums []int, index int, current []int, result *[][]int) { // Recursive function to generate all subsets of a set ...}",
        "difficulty": "Hard",
        "question": "Generate all subsets of a given set of integers.",
        "answerImage": "",
        "answerCpp": "void generateSubsets(const vector<int>& nums, int index, vector<int>& current, vector<vector<int>>& result) { if (index == nums.size()) { result.push_back(current); return; } generateSubsets(nums, index + 1, current, result); current.push_back(nums[index]); generateSubsets(nums, index + 1, current, result); current.pop_back();}",
        "answerGo": "func generateSubsets(nums []int, index int, current []int, result *[][]int) { if index == len(nums) { subset := make([]int, len(current)) copy(subset, current) *result = append(*result, subset) return } generateSubsets(nums, index+1, current, result) current = append(current, nums[index]) generateSubsets(nums, index+1, current, result) current = current[:len(current)-1}"
      },
      {
        "id": "unique paths",
        "category": "Combinatorics",
        "placeHolderCpp": "int uniquePaths(int m, int n) { // Number of unique paths in an m x n grid int paths = ...}",
        "placeHolderGo": "func uniquePaths(m int, n int) int { // Number of unique paths in an m x n grid paths := ...}",
        "difficulty": "Hard",
        "question": "top-left to the bottom-right unique paths",
        "answerImage": "",
        "answerCpp": "int uniquePaths(int m, int n) { int paths[m][n]; for (int i = 0; i < m; i++) paths[i][0] = 1; for (int j = 0; j < n; j++) paths[0][j] = 1; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { paths[i][j] = paths[i - 1][j] + paths[i][j - 1]; } } return paths[m - 1][n - 1];}",
        "answerGo": "func uniquePaths(m int, n int) int { paths := make([][]int, m) for i := range paths { paths[i] = make([]int, n) } for i := 0; i < m; i++ { paths[i][0] = 1 } for j := 0; j < n; j++ { paths[0][j] = 1 } for i := 1; i < m; i++ { for j := 1; j < n; j++ { paths[i][j] = paths[i-1][j] + paths[i][j-1 } } return paths[m-1][n-1}"
      },
      {
        "id": "count combis",
        "category": "Combinatorics",
        "placeHolderCpp": "int countCombinations(int n, int k) { // Base cases if (k == 0 || k == n) return 1; ...}",
        "placeHolderGo": "func countCombinations(n int, k int) int { // Base cases if k == 0 || k == n { return 1 } ...}",
        "difficulty": "Easy",
        "question": "Ways to choose k items from n items (no order)",
        "answerImage": "",
        "answerCpp": "int countCombinations(int n, int k) { if (k == 0 || k == n) return 1; return countCombinations(n - 1, k - 1) + countCombinations(n - 1, k);}",
        "answerGo": "func countCombinations(n int, k int) int { if k == 0 || k == n { return 1 } return countCombinations(n-1, k-1) + countCombinations(n-1, k)}"
      },
      {
        "id": "Triangle area",
        "category": "Geometry",
        "placeHolderCpp": "double areaOfTriangle(Point a, Point b, Point c) { ...}",
        "placeHolderGo": "func areaOfTriangle(a, b, c Point) float64 { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Medium",
        "question": "Area triangle Heron",
        "answerImage": "",
        "answerCpp": "",
        "answerGo": "func areaOfTriangle(a, b, c Point) float64 { sideAB := math.Sqrt(math.Pow(b.X-a.X, 2) + math.Pow(b.Y-a.Y, 2)) sideBC := math.Sqrt(math.Pow(c.X-b.X, 2) + math.Pow(c.Y-b.Y, 2)) sideCA := math.Sqrt(math.Pow(a.X-c.X, 2) + math.Pow(a.Y-c.Y, 2)) s := (sideAB + sideBC + sideCA) / 2 return math.Sqrt(s - sideCA))}"
      },
      {
        "id": "line inters.",
        "category": "Geometry",
        "placeHolderCpp": "bool doIntersect(Point p1, Point q1, Point p2, Point q2) { ...}",
        "placeHolderGo": "func doIntersect(p1, q1, p2, q2 Point) bool { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Easy",
        "question": "Line intersection",
        "answerImage": "",
        "answerCpp": "", 
        "answerGo": ""
      },
      {
        "id": "Convex hull",
        "category": "Geometry",
        "placeHolderCpp": "vector<Point> convexHull(vector<Point>& points) { ...}",
        "placeHolderGo": "func convexHull(points []Point) []Point { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Hard",
        "question": "Convex Hull",
        "answerImage": "",
        "answerCpp": "",
        "answerGo": ""
      },
      {
        "id": "Factorial",
        "category": "Recursion",
        "placeHolderCpp": "int factorial(int n) { ...}",
        "placeHolderGo": "func factorial(n int) int { ...}",
        "difficulty": "Easy",
        "question": "Write a recursive algorithm to calculate the factorial of a number.",
        "answerImage": "",
        "answerCpp": "", 
        "answerGo": ""
      },
      {
        "id": "KMP",
        "category": "String",
        "placeHolderCpp": "vector<int> getLps(const string& p) { ...}void kmp(const string& t, const string& p) { ...}",
        "placeHolderGo": "func getLps(p string) []int { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Hard",
        "question": "KMP (Knuth-Morris-Pratt) algorithm",
        "answerImage": "../code-snipets/kmp.png",
        "answerCpp": "vector<int> getLps(const string& p) { int sp = p.length(); vector<int> lps(sp, 0); int i = 1, j = 0; while (i < sp) { if (p[i] == p[j]) lps[i++] = ++j; else if (j>0) j = lps[j-1]; else lps[i++] = 0; } return lps;}void kmp(const string& t, const string& p) { int st = t.length(); int sp = p.length(); int i = 0, j = 0; vector<int> lps = getLps(p); while (i < st) { if (t[i] == p[j]) i++, j++; if (j == m) cout << \"found at \" << i - j, j = lps[j - 1]; else if (i < n && t[i] != p[j]) j ? j = lps[j - 1] : i++; }}",
        "answerGo": "func getLps(p string) []int { sp := len(p) lps := make([]int, sp) j := 0 for i := 1; i < sp; { if p[i] == p[j] { j++ lps[i] = j i++ } else { if j != 0 { j = lps[j-1 } else { lps[i] = 0 i++ } } } return lps}func kmp(t, p string) { st := len(t) sp := len(p) lps := getLps(p) j := 0 for i := 0; i < st; { if p[j] == t[i] { i++ j++ } if j == sp { fmt.Printf(\"found at %d\", i-j) j = lps[j-1 } else if i < st && p[j] != t[i] { if j != 0 { j = lps[j-1 } else { i++ } } }}"
      },
      {
        "id": "Rabin Karp",
        "category": "String",
        "placeHolderCpp": "void rabinKarp(string text, string pattern) { ...}",
        "placeHolderGo": "func rabinKarp(text, pattern string, d, q int) { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Hard",
        "question": "Rabin-Karp",
        "answerImage": "",
        "answerCpp": "", 
        "answerGo": "func rabinKarp(text, pattern string, d, q int) { n := len(text) m := len(pattern) p := 0 t := 0 h := 1 for i := 0; i < m-1; i++ { h = d % q } for i := 0; i < m; i++ { p = (d*p + int(pattern[i])) % q t = (d*t + int(text[i])) % q } for i := 0; i <= n-m; i++ { if p == t { match := true for j := 0; j < m; j++ { if text[i+j] != pattern[j] { match = false break } } if match { fmt.Printf(\"Pattern found at index %d\", i) } } if i < n-m { t = (d*(t-int(text[i])*h) + int(text[i+m])) % q if t < 0 { t = (t + q) } } }}"
      },
      {
        "id": "split",
        "category": "String",
        "placeHolderCpp": "vector<string> splitSentence(const string& sentence) { ...}",
        "placeHolderGo": "{ ...}",
        "difficulty": "Medium",
        "question": "Split a sentence into words",
        "answerImage": "",
        "answerCpp": "vector<string> splitSentence(const string& sentence) { stringstream ss(sentence); return { istream_iterator<string>(ss), {} };}",
        "answerGo": ""
      },
      {
        "id": "LCP",
        "category": "String",
        "placeHolderCpp": "string findLCP(vector<string>& strs) { ...}",
        "placeHolderGo": "func (t *Trie) Insert(word string) { ...}",
        "spaceComplexity": "O()",
        "timeComplexity": "O()",
        "difficulty": "Hard",
        "question": "Longest Common Prefix (LCP)",
        "answerImage": "",
        "answerCpp": "void insert(string word) { TrieNode* node = root; for (char c : word) { if (!node->children.count(c)) { node->children[c] = new TrieNode(); } node = node->children[c]; } node->isEnd = true;}string findLCP(vector<string>& strs) { root = new TrieNode(); for (string word : strs) { insert(word); } TrieNode* node = root; string prefix = \"\"; while (node && node->children.size() == 1) { for (auto it : node->children) { node = it.second; prefix += it.first; break; } } return prefix;}",
        "answerGo": "type TrieNode struct { Children map[rune]*TrieNode IsEnd bool}type Trie struct { Root *TrieNode}func NewTrie() *Trie { return &Trie{Root: &TrieNode{Children: make(map[rune]*TrieNode)}}}func (t *Trie) Insert(word string) { node := t.Root for _, c := range word { if _, exists := node.Children[c]; !exists { node.Children[c] = &TrieNode{Children: make(map[rune]*TrieNode)} } node = node.Children[c } node.IsEnd = true}func FindLCP(strs []string) string { trie := NewTrie() for _, word := range strs { trie.Insert(word) } node := trie.Root prefix := \"\" for node != nil && len(node.Children) == 1 { for c, child := range node.Children { node = child prefix += string(c) break } } return prefix}"
      }
    ],
    "SystemDesign": []
  }
